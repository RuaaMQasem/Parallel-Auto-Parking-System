/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>
#include <stdlib.h>
#include "StdTypes.h"
#include "Utils.h"
#include "rcc.h"
#include "rcc_reg.h"
#include "GPIO_interface.h"
#include "GPIO_private.h"
#include "nvic.h"
#include "nvic_reg.h"
#include "extint.h"
#include "extint_reg.h"
#include "extint_types.h"
#include "Timer_interface.h"
#include "Auto_Parking_Interface.h"
#include "Ultra_Sonics_Interface.h"
#include "Motors_interface.h"
#include "Motors_config.h"
#include "STK_interface.h"
#include "Application_Interface.h"
#include "Application_config.h"
#include "UART_interface.h"
/*#define GPIO_BASE	(0x48000000)
#define GPIOA_MODE_OFFSET	(0x00)
#define GPIOA_TYPE_OFFSET	(0x04)
#define GPIOA_ODR_OFFSET	(0x14)
#define GPIOA_SET_RESET_OFFSET	(0x18)
#define GPIOA_MODE_REG	(*(volatile u32*)((GPIO_BASE)+(GPIOA_MODE_OFFSET)))
#define GPIOA_TYPE_REG	(*(volatile u32*)((GPIO_BASE)+(GPIOA_TYPE_OFFSET)))
#define GPIOA_ODR_REG	(*(volatile u32*)((GPIO_BASE)+(GPIOA_ODR_OFFSET)))
#define GPIOA_SET_RESET_REG	(*(volatile u32*)((GPIO_BASE)+(GPIOA_SET_RESET_OFFSET)))
*/

//#include "FreeRTOS.h"
//#include "task.h"
//#include "FreeRTOSConfig.h"
//#include "semphr.h"

/*volatile u8 led_flag=0,button_flag=0;
volatile u8 ButtonState=1;
volatile u8 flag1,flag2,flag3,flag4;
void ext13__(void)
{
	if(led_flag==0)
	{
		MGPIO_voidSetPinValue(GPIOA,PIN5,GPIO_HIGH);
		led_flag=1;
	}
	else if(led_flag==1)
	{
		MGPIO_voidSetPinValue(GPIOA,PIN5,GPIO_LOW);
		led_flag=0;
	}
}
*/



//void button_task(void * Pvparameter);
//void Led_on(void * Pvparameter);
//xTaskHandle Led_on_Handle;
//xTaskHandle led_off_handle;
//BaseType_t  Red_Led_Task_Check;
//xSemaphoreHandle buttonsemaphore= NULL;

void (*ptr)(void)=&Park_Interrupt;
volatile u8 park_flag=0;
volatile u8 Timer_flag=0;
u16 ultraSonic_Reads[]={0,0,0,0};
volatile u8 Direction='P';
volatile u8 speed=15;


int main(void)
{
    /* Loop forever */

	/*Auto_Parking_RCC_Init();
		Auto_Parking_GPIO_Output_Pin_Init();
		Auto_Parking_NVIC_Init();
		Auto_Parking_TIMER_Init();
		Auto_Parking_GPIO_Input_Pin_Init();
		UART_init();

		Ultra_Sonic_Init();
		MSTK_voidInit();
	//u8 count=0;
	u16 reads[4]={0};
		for(;;)
		{
			Ultra_Sonic_Runable();
			Ultra_GetReads(reads,4);
			Front_Motor_Right(100);
			Direction=MUART_u8Receive();
			Bluetooth_Mode(Direction, speed,reads);*/
//			Rear_Motor_Forward(speed);
//			if(park_flag==0){
//			Parking_Check(ultraSonic_Reads);
//			}
//			else if(park_flag==1){
//				Front_Motor_Free_Stop();
//				Rear_Motor_Free_Stop();
//			//Auto_Parking(ultraSonic_Reads);
//			}
//			else if(park_flag==2){
//				Front_Motor_Free_Stop();
//				Rear_Motor_Free_Stop();
//
//			break;
//			}
//		}



	Auto_Parking_RCC_Init();
	Auto_Parking_GPIO_Output_Pin_Init();
	Auto_Parking_NVIC_Init();
	Auto_Parking_TIMER_Init();
	Auto_Parking_GPIO_Input_Pin_Init();
	UART_init();

	Ultra_Sonic_Init();
	MSTK_voidInit();
//u8 count=0;
u16 reads[4]={0};
	for(;;)
	{
		Ultra_Sonic_Runable();
		Ultra_GetReads(reads,4);

//		Rear_Motor_Forward(35);
//		Rear_Motor_Free_Stop();
//		Rear_Motor_Backward(35);
//		Rear_Motor_Force_Stop();
//		Front_Motor_Right(100);
//		Front_Motor_Left(100);
//		Rear_Motor_Forward(15);
//						if(park_flag==0){
//						Parking_Check(reads);
//						}
//						else if(park_flag==1){
//							Front_Motor_Free_Stop();
//							Rear_Motor_Free_Stop();
//						//Auto_Parking(ultraSonic_Reads);
//						}
//						else if(park_flag==2){
//							Front_Motor_Free_Stop();
//							Rear_Motor_Free_Stop();
//							break;
//						}
//
//
//
//
	}
}


void Auto_Mode(u16 speed,u16 *arr){
	Rear_Motor_Forward(speed);
if(park_flag==0){
	Parking_Check(ultraSonic_Reads);
}
else if(park_flag==1){
	Front_Motor_Free_Stop();
	Rear_Motor_Free_Stop();
	//Auto_Parking(ultraSonic_Reads);
	}
else if(park_flag==2){
	Front_Motor_Free_Stop();
	Rear_Motor_Free_Stop();
	//break;
	}
}

void Bluetooth_Mode(u8 Direction, u16 speed,u16 *arr){
switch(Direction){
case 'F':
	Rear_Motor_Forward(speed);
	break;
case 'B':
	Rear_Motor_Backward(speed);
	break;
case 'R':
	Front_Motor_Right(100);
	break;
case 'L':
	Front_Motor_Left(100);
	break;
case 'I':
	Front_Motor_Right(100);
	Rear_Motor_Forward(speed);
case 'G':
	Front_Motor_Left(100);
	Rear_Motor_Forward(speed);
case 'J':
	Front_Motor_Right(100);
	Rear_Motor_Backward(speed);
case 'H':
	Front_Motor_Left(100);
	Rear_Motor_Backward(speed);
case 'S':
	Front_Motor_Free_Stop();
	Rear_Motor_Free_Stop();
case 'X':
	Auto_Mode(speed,arr);

default:
	break;
}
}


void Normal_Mode(u8 Direction, u16 spead,u16 *arr){
switch(Direction){
case 'F':
	Rear_Motor_Forward(spead);
	break;
case 'B':
	Rear_Motor_Backward(spead);
	break;
case 'R':
	Front_Motor_Right(spead);
	break;
case 'L':
	Front_Motor_Left(spead);
	break;
default:
	break;
}
}




void Auto_Poilot(u16 *arr){
	Front_Motor_Free_Stop();
	Rear_Motor_Forward(50);

}






void Parking_Check(u16 *arr){
u32 distance,time_free;
//detect a potential parking spot

//flag!=1
while(park_flag!=1)
{
	//if(flag==2)
	//break
	Ultra_Sonic_Runable();
	Ultra_GetReads(arr, 4);
	//Stay_Straight(arr);
	if(arr[1]>= 25 && arr[1]<=70 && Timer_flag==0/*&& arr[2]<=Width+5*/){

	//set a flag
	Timer_flag=1;

	//starts systick
	MSTK_voidSetIntervalSingle (10000000, ptr);
	}

if(arr[1]< 20&&/*arr[2]<=Width*2+10&&*/Timer_flag==1){
	//check timer flag

time_free=MSTK_voidGetElapsedTime();
time_free/=1000000;

MSTK_voidStopTimer();
distance=time_free*SPEED_AT_15_DUTY;

if(distance>=Minimum_Parking_Space){
	//if condition on the second ultrasonic
	park_flag=1;
	Rear_Motor_Forward(15);
	Front_Motor_Left(100);
	for(volatile u32 i=0;i<1000000;i++);
	Rear_Motor_Free_Stop();
	Auto_Parking(arr);

}
else{
	//Front_Motor_Free_Stop();
	Rear_Motor_Forward(15);
	Timer_flag=0;
}

}
}
}





void Auto_Parking(u16 *arr){
	//if(park_flag==1){

	//Stay_Straight(arr);

	/* يمين العجل هنلف و ورا هنرجع */
	for(volatile u32 i=0;i<1000000;i++);
	Front_Motor_Right(100);
	Rear_Motor_Backward(25);
	while(arr[3]>30)
	{
		Ultra_Sonic_Runable();
		Ultra_GetReads(arr, 4);
	}
	Rear_Motor_Free_Stop();
	for(volatile u32 i=0;i<2000000;i++);
	Front_Motor_Left(100);
	Rear_Motor_Backward(25);
	while(arr[3]>20)
	{
		Ultra_Sonic_Runable();
		Ultra_GetReads(arr, 4);
	}

	Front_Motor_Free_Stop();
	Rear_Motor_Free_Stop();
//	for(u32 i=0;i<20000;i++){}
//	Front_Motor_Free_Stop();
//	Rear_Motor_Free_Stop();
//	while(arr[3]>=20&&arr[1]>=30){
//    Front_Motor_Left(100);
//	Rear_Motor_Backward(50);
//		}
//	while(arr[0]>=40&&arr[1]>=25){
//			Ultra_GetReads(arr,4);
//			Front_Motor_Right(100);
//			Rear_Motor_Forward(50);
//	}
//	Front_Motor_Free_Stop();
//	Rear_Motor_Free_Stop();
//	park_flag=2;

}






//helpful functions
void Park_Interrupt(){
	park_flag=1;
}


void Stay_Straight(u16 *arr){
	while(abs(arr[1]-arr[2])>=10)
	{
	if(arr[1]>arr[2]){
	Front_Motor_Right(100);
	}else if(arr[1]<arr[2]){
	Front_Motor_Left(100);
	}
	}
}



void Emergency_Stop(u16 *arr){
	Ultra_GetReads(arr,4);
	if (arr[0]<=10){
	Front_Motor_Free_Stop();
	Rear_Motor_Free_Stop();
}
}



void Obstacle_Avoidance(u16 *arr){
	Ultra_GetReads(arr,4);
	while(arr[0]<=20){
		Front_Motor_Right(100);
		Rear_Motor_Forward(50);
	}

}








//	extint_port_select(EXTI6,PC);
//	extint_enableLine(EXTI6,BOTH,ext3_CH1_);
//Red_Led_Task_Check=xTaskCreate(Led_on,"led on", 85, NULL, 2, &Led_on_Handle);
	//Red_Led_Task_Check=xTaskCreate(button_task,"button", 85, NULL, 1, &led_off_handle);

	//vSemaphoreCreateBinary(buttonsemaphore);

	//vTaskStartScheduler();



//void Led_on(void * Pvparameter)
//{
//	portTickType Freq = 250;
//	portTickType Start = xTaskGetTickCount();
//	while(1)
//	{
//		if(pdTRUE == xSemaphoreTake(buttonsemaphore,100))
//				{
//
//					 if (ButtonState == 0){
//						 if(led_flag==0)
//						 	{
//						 		MGPIO_voidSetPinValue(GPIOA,PIN5,GPIO_HIGH);
//						 		led_flag=1;
//						 	}
//						 	else if(led_flag==1)
//						 	{
//						 		MGPIO_voidSetPinValue(GPIOA,PIN5,GPIO_LOW);
//						 		led_flag=0;
//						 	}
//						 ButtonState = 1;
//					 }
//					 xSemaphoreGive(buttonsemaphore);
//				 }
//				 else {
//					 vTaskDelay(10);
//				 }
//				 vTaskDelayUntil(&Start,Freq);
//	}
//
//}
//
//void button_task(void * Pvparameter)
//{
//	portTickType Freq = 100;
//	portTickType Start = xTaskGetTickCount();
//	while(1)
//	{
//		if (MGPIO_voidgetPinValue(GPIOC, PIN13)==0)
//		{
//
//			if(pdTRUE == xSemaphoreTake(buttonsemaphore,100))
//					{
//
//						 ButtonState = 0;
//
//						 xSemaphoreGive(buttonsemaphore);
//					 }
//					 else {
//						 vTaskDelay(10);
//
//					 }
//
//		}
//				 vTaskDelayUntil(&Start,Freq);
//	}
//
//}


